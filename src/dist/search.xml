<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubeadm 基本使用</title>
      <link href="/2022/06/02/kubeadm-used/"/>
      <url>/2022/06/02/kubeadm-used/</url>
      
        <content type="html"><![CDATA[<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><ol><li>查看有效Token列表<pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm token list</code></pre></li><li>生成 Join 集群 Token<pre class="language-bash" data-language="bash"><code class="language-bash">kubadm token create --print-join-command  <span class="token comment"># 默认有效期24小时,若想久一些可以结合–ttl参数,设为0则用不过期</span></code></pre><h1 id="Cert"><a href="#Cert" class="headerlink" title="Cert"></a>Cert</h1></li><li>生成 cert-hash<pre class="language-bash" data-language="bash"><code class="language-bash">openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt <span class="token operator">|</span> openssl rsa -pubin -outform der <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>/dev/null <span class="token operator">|</span> openssl dgst -sha256 -hex <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/^.* //'</span></code></pre></li><li>获取集群控制节点加入 certificate-key <pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm certs certificate-key</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubenetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rust 变量</title>
      <link href="/2022/06/02/rust-variables/"/>
      <url>/2022/06/02/rust-variables/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Rust 变量默认是无法改变的。这是Rust推动的特点之一，这样可以利用Rust提供的安全、易并发的方式来编写代码。不过我们也可以选择让变量可变。</p><p>当变量不可变时，一旦将值绑定到变量上，就无法更改该值。例如以下示例</p><p>首先创建一个项目 variables </p><pre class="language-bash" data-language="bash"><code class="language-bash">cargo new variables</code></pre><p>在 variables 文件夹中找到文件 src/main.rs</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>保存后运行命令 <code>cargo run</code>。会得到以下报错信息：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ cargo run   Compiling variables v0.1.0 <span class="token punctuation">(</span>/Users/binwan/Documents/binwan-dev/rust-hello/variables<span class="token punctuation">)</span>error<span class="token punctuation">[</span>E0384<span class="token punctuation">]</span>: cannot assign twice to immutable variable <span class="token variable"><span class="token variable">`</span>x<span class="token variable">`</span></span> --<span class="token operator">&gt;</span> src/main.rs:4:2  <span class="token operator">|</span><span class="token number">2</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token operator">|</span>         -  <span class="token operator">|</span>         <span class="token operator">|</span>  <span class="token operator">|</span>         first assignment to <span class="token variable"><span class="token variable">`</span>x<span class="token variable">`</span></span>  <span class="token operator">|</span>         help: consider making this binding mutable: <span class="token variable"><span class="token variable">`</span>mut x<span class="token variable">`</span></span><span class="token number">3</span> <span class="token operator">|</span>     println<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span>, x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">4</span> <span class="token operator">|</span>     x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token operator">|</span>     ^^^^^ cannot assign twice to immutable variableFor <span class="token function">more</span> information about this error, try <span class="token variable"><span class="token variable">`</span>rustc --explain E0384<span class="token variable">`</span></span><span class="token builtin class-name">.</span>error: could not compile <span class="token variable"><span class="token variable">`</span>variables<span class="token variable">`</span></span> due to previous error</code></pre><p><code>cannot assign twice to immutable variable 'x'</code> 指示变量x不能被分配两次。<br>当我们尝试在代码中更改一个不可更改的值时，编译器将会提示错误，我们必须重视这个错误。如果代码的一部分假设某个值永远不会更改，而代码的另一部分更改该值，则代码的第一部分可能无法执行其设计的操作。这种错误很难在事后跟踪，特别是第二段代码更改该值时。</p><p>可变形有时也是非常有用的，可以使代码编写起来更方便。Rust中可以通过添加 <code>mut</code> 在变量名称前面。添加该指示代码后变量将可以被更改。<br>例如以下示例：</p><p>在文件 <code>src/main.rs</code> 中：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行代码 <code>cargo run</code> 后输出以下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ cargo run   Compiling variables v0.1.0 <span class="token punctuation">(</span>/Users/binwan/Documents/binwan-dev/rust-hello/variables<span class="token punctuation">)</span>    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.14s     Running <span class="token variable"><span class="token variable">`</span>target/debug/variables<span class="token variable">`</span></span>The value of x is: <span class="token number">5</span>The value of x is: <span class="token number">6</span></code></pre><p>在使用更改值时，通常有许多因素需要考虑。例如，在使用大型数据结构时，使用 <code>mut</code> 就地更改要比复制和返回新实例更快。对于较小的数据结构，创建新实例并以更具函数式的编程风格编写可能更容易思考。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>和变量相似，常量也是声明后无法更改，但是它们之间又有一些不同。<br>常量是任何情况下都不能更改的，可以使用 <code>const</code> 代码声明一个常量，同时常量需要指定数据类型（例如：u32 等）。<br>常量只能设置为常量表达式，不能设置为运行时计算的结果。<br>例如：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">THREE_HOURS_IN_SECONDS</span><span class="token punctuation">:</span> <span class="token keyword">u32</span> <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><h2 id="重影（shadowing）"><a href="#重影（shadowing）" class="headerlink" title="重影（shadowing）"></a>重影（shadowing）</h2><p>变量重影可以申明一个同名的变量，并将前一变量的值重影。并且在作用域不同的情况下，可以局部重影。使用关键字 <code>let</code> 。<br>示例：src/main.rs</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token keyword">let</span> x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is the inner scope is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The value of x is: {}"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行命令 <code>cargo run</code> 输出如下：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ cargo run   Compiling variables v0.1.0 <span class="token punctuation">(</span>/Users/binwan/Documents/binwan-dev/rust-hello/variables<span class="token punctuation">)</span>    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.12s     Running <span class="token variable"><span class="token variable">`</span>target/debug/variables<span class="token variable">`</span></span>The value of x is the inner scope is: <span class="token number">12</span>The value of x is: <span class="token number">6</span></code></pre><p>可以看出在局部作用域的重影变量并没有改变全局的重影，这说明重影作用范围是可以局部的。<br>重影和变量标记不同，重影是可以更改变量类型的，而<code>mut</code>只能改变值但不能更改类型。<br>例如：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> spaces <span class="token operator">=</span> <span class="token string">"     "</span><span class="token punctuation">;</span><span class="token keyword">let</span> spaces <span class="token operator">=</span> spaces<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这是被允许的。<br>当我们使用<code>mut</code> 时：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> spaces <span class="token operator">=</span> <span class="token string">"      "</span><span class="token punctuation">;</span>spaces <span class="token operator">=</span> spaces<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行后会出现<code>mismatched types</code>错误。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ cargo run   Compiling variables v0.1.0 <span class="token punctuation">(</span>file:///projects/variables<span class="token punctuation">)</span>error<span class="token punctuation">[</span>E0308<span class="token punctuation">]</span>: mismatched types --<span class="token operator">&gt;</span> src/main.rs:3:14  <span class="token operator">|</span><span class="token number">3</span> <span class="token operator">|</span>     spaces <span class="token operator">=</span> spaces.len<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">|</span>              ^^^^^^^^^^^^ expected <span class="token variable"><span class="token variable">`</span><span class="token operator">&amp;</span>str<span class="token variable">`</span></span>, found <span class="token variable"><span class="token variable">`</span>usize<span class="token variable">`</span></span>For <span class="token function">more</span> information about this error, try <span class="token variable"><span class="token variable">`</span>rustc --explain E0308<span class="token variable">`</span></span><span class="token builtin class-name">.</span>error: could not compile <span class="token variable"><span class="token variable">`</span>variables<span class="token variable">`</span></span> due to previous error</code></pre><p><a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">官方原文</a></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rust 命令行参数</title>
      <link href="/2022/06/02/rust-args/"/>
      <url>/2022/06/02/rust-args/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/rust-lang/book/blob/main/src/ch12-01-accepting-command-line-arguments.md">官方文档 Args</a></p><p>创建一个控制台项目</p><pre class="language-bash" data-language="bash"><code class="language-bash">cargo new minigrep<span class="token builtin class-name">cd</span> minigrep</code></pre><p>minigrep 能够接受两个命令行参数：文件名和要搜索的字符串。也就是说我们希望能够使用 cargo run、要搜索的字符串和被搜索的文件的路径来运行程序，像这样：</p><pre class="language-bash" data-language="bash"><code class="language-bash">cargo run searchstring example-filename.txt</code></pre><p>读取参数值<br>为了确保 minigrep 能够获取传递给它的命令行参数的值，我们需要一个 Rust 标准库提供的函数，也就是 std::env::args。这个函数返回一个传递给程序的命令行参数的 迭代器（iterator）。我们会在 第十三章 全面的介绍它们。但是现在只需理解迭代器的两个细节：迭代器生成一系列的值，可以在迭代器上调用 collect 方法将其转换为一个集合，比如包含所有迭代器产生元素的 vector。</p><p>使用示例 12-1 中的代码来读取任何传递给 minigrep 的命令行参数并将其收集到一个 vector 中。</p><p>文件名: src/main.rs</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>env<span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> args<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{:?}"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>示例 12-1：将命令行参数收集到一个 vector 中并打印出来</p><p>首先使用 use 语句来将 std::env 模块引入作用域以便可以使用它的 args 函数。注意 std::env::args 函数被嵌套进了两层模块中。正如 第七章 讲到的，当所需函数嵌套了多于一层模块时，通常将父模块引入作用域，而不是其自身。这便于我们利用 std::env 中的其他函数。这比增加了 use std::env::args; 后仅仅使用 args 调用函数要更明确一些，因为 args 容易被错认成一个定义于当前模块的函数。</p><blockquote><p><strong>NOTE</strong><br>args 函数和无效的 Unicode<br>注意 std::env::args 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 std::env::args_os 代替。这个函数返回 OsString 值而不是 String 值。这里出于简单考虑使用了 std::env::args，因为 OsString 值每个平台都不一样而且比 String 值处理起来更为复杂。’</p></blockquote><p>在 main 函数的第一行，我们调用了 env::args，并立即使用 collect 来创建了一个包含迭代器所有值的 vector。collect 可以被用来创建很多类型的集合，所以这里显式注明 args 的类型来指定我们需要一个字符串 vector。虽然在 Rust 中我们很少会需要注明类型，然而 collect 是一个经常需要注明类型的函数，因为 Rust 不能推断出你想要什么类型的集合。</p><p>最后，我们使用调试格式 :? 打印出 vector。让我们尝试分别用两种方式（不包含参数和包含参数）运行代码：</p><pre class="language-bash" data-language="bash"><code class="language-bash">cargo run   Compiling minigrep v0.1.0 <span class="token punctuation">(</span>file:///projects/minigrep<span class="token punctuation">)</span>    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.61s     Running <span class="token variable"><span class="token variable">`</span>target/debug/minigrep<span class="token variable">`</span></span><span class="token punctuation">[</span><span class="token string">"target/debug/minigrep"</span><span class="token punctuation">]</span>cargo run needle haystack   Compiling minigrep v0.1.0 <span class="token punctuation">(</span>file:///projects/minigrep<span class="token punctuation">)</span>    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">1</span>.57s     Running <span class="token variable"><span class="token variable">`</span>target/debug/minigrep needle haystack<span class="token variable">`</span></span><span class="token punctuation">[</span><span class="token string">"target/debug/minigrep"</span>, <span class="token string">"needle"</span>, <span class="token string">"haystack"</span><span class="token punctuation">]</span></code></pre><p>注意 vector 的第一个值是 “target/debug/minigrep”，它是我们二进制文件的名称。这与 C 中的参数列表的行为相匹配，让程序使用在执行时调用它们的名称。如果要在消息中打印它或者根据用于调用程序的命令行别名更改程序的行为，通常可以方便地访问程序名称，不过考虑到本章的目的，我们将忽略它并只保存所需的两个参数。</p><p>将参数值保存进变量<br>打印出参数 vector 中的值展示了程序可以访问指定为命令行参数的值。现在需要将这两个参数的值保存进变量这样就可以在程序的余下部分使用这些值了。让我们如示例 12-2 这样做：</p><p>文件名: src/main.rs</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span></span>env<span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> args<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> query <span class="token operator">=</span> <span class="token operator">&amp;</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> filename <span class="token operator">=</span> <span class="token operator">&amp;</span>args<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Searching for {}"</span><span class="token punctuation">,</span> query<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"In file {}"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>示例 12-2：创建变量来存放查询参数和文件名参数</p><p>正如之前打印出 vector 时所所看到的，程序的名称占据了 vector 的第一个值 args[0]，所以我们从索引 1 开始。minigrep 获取的第一个参数是需要搜索的字符串，所以将其将第一个参数的引用存放在变量 query 中。第二个参数将是文件名，所以将第二个参数的引用放入变量 filename 中。</p><p>我们将临时打印出这些变量的值来证明代码如我们期望的那样工作。使用参数 test 和 sample.txt 再次运行这个程序：</p><pre class="language-bash" data-language="bash"><code class="language-bash">cargo run <span class="token builtin class-name">test</span> sample.txt   Compiling minigrep v0.1.0 <span class="token punctuation">(</span>file:///projects/minigrep<span class="token punctuation">)</span>    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.0s     Running <span class="token variable"><span class="token variable">`</span>target/debug/minigrep <span class="token builtin class-name">test</span> sample.txt<span class="token variable">`</span></span>Searching <span class="token keyword">for</span> <span class="token builtin class-name">test</span>In <span class="token function">file</span> sample.txt</code></pre><p>好的，它可以工作！我们将所需的参数值保存进了对应的变量中。之后会增加一些错误处理来应对类似用户没有提供参数的情况，不过现在我们将忽略他们并开始增加读取文件功能。</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 kubeadm 安装 kubernetes 集群</title>
      <link href="/2022/06/02/kubeadm-k8s-install/"/>
      <url>/2022/06/02/kubeadm-k8s-install/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍如何通过kubeadm安装一个高可用kubernetes集群。</p><h3 id="1-检查并设置主机环境"><a href="#1-检查并设置主机环境" class="headerlink" title="1. 检查并设置主机环境"></a>1. 检查并设置主机环境</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 关闭 swap （这一步必须要执行）</span><span class="token function">sudo</span> swapoff -a<span class="token comment"># 查看 swap 分区情况</span><span class="token function">sudo</span> <span class="token function">free</span> -m<span class="token comment"># 永久关闭 swap</span><span class="token function">sudo</span> <span class="token function">vim</span> /etc/fstab<span class="token comment"># 在swap分区这行前加 # 禁用掉，保存退出</span><span class="token comment"># 修改机器名称来唯一标识机器地址</span><span class="token function">sudo</span> hostnamectl set-hostname <span class="token operator">&lt;</span>node-name<span class="token operator">&gt;</span><span class="token comment"># 检查 br_netfilter</span>lsmod <span class="token operator">|</span> <span class="token function">grep</span> br_netfilter <span class="token comment"># 检查是否输出有 br_netfilter</span><span class="token comment"># 如果没有输出执行以下命令</span><span class="token function">sudo</span> modprobe br_netfilter<span class="token comment"># 允许 iptables 检查流量</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/modules-load.d/k8s.conf</span>br_netfilterEOF</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/sysctl.d/k8s.conf</span>net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF</span><span class="token function">sudo</span> sysctl --system</code></pre><h3 id="2-安装容器运行时"><a href="#2-安装容器运行时" class="headerlink" title="2. 安装容器运行时"></a>2. 安装容器运行时</h3><p>容器运行时有 Docker、Contrainerd 等多种，本文只描述 Docker、Contrainerd 安装。<br> PS：Kubernetes 从 1.24.0 版本开始不在接受默认docker运行时，需要安装docker-shim，故推荐切换到Contrainerd运行时。另外，Docker从1.20.0版本开始底层已经依赖于Contrainerd运行时。</p><p>a. 安装 Docker 参考链接 <a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><p>b. 安装 Containerd 安装方法参考 <a href="https://github.com/containerd/containerd">https://github.com/containerd/containerd</a><br>安装完成后执行下述命令配置：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/containerdcontainerd config default <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/containerd/config.toml<span class="token comment"># 配置SystemCgroup以及 pause 为中国源</span><span class="token function">vim</span> /etc/containerd/config.toml<span class="token comment"># 查找 [plugins."io.containerd.grpc.v1.cri".cni]</span><span class="token comment"># 更改 SystemdCgroup = false 为 true</span><span class="token comment"># 查找 sandbox_image 并修改 sandbox_image = "registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6" （此处可以修改为私有源）</span>systemctl restart containerdsystemctl <span class="token builtin class-name">enable</span> containerd<span class="token comment">#如果机器上还有docker </span>systemctl disable docker.service</code></pre><h3 id="3-安装kubeadm、kubectl、kubelet"><a href="#3-安装kubeadm、kubectl、kubelet" class="headerlink" title="3. 安装kubeadm、kubectl、kubelet"></a>3. 安装kubeadm、kubectl、kubelet</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">######## yum 安装 ########</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/yum.repos.d/kubernetes.repo</span>[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg         https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgkeepcache = 0EOF</span><span class="token function">sudo</span> yum list --showduplicates kubeadm --disableexcludes<span class="token operator">=</span>kubernetes <span class="token comment"># 查看需要安装的版本（推荐安装比最新版本低两个次版本）</span><span class="token function">sudo</span> yum <span class="token function">install</span> -y kubeadm-<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span> kubectl-<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span> kubelet-<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span><span class="token comment"># 添加环境变量 kubectl</span><span class="token builtin class-name">echo</span> <span class="token string">"export KUBECONFIG=/etc/kubernetes/admin.conf"</span> <span class="token operator">&gt;&gt;</span> ~/.bashrc<span class="token builtin class-name">source</span> ~/.bashrc</code></pre><h3 id="4-安装第一个控制节点"><a href="#4-安装第一个控制节点" class="headerlink" title="4. 安装第一个控制节点"></a>4. 安装第一个控制节点</h3><p>生成 kubeadm-config</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span><span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> ./kubeadm-config.yaml</span>apiVersion: kubeadm.k8s.io/v1beta3kind: InitConfigurationnodeRegistration:  criSocket: &lt;container-sock&gt;  imagePullPolicy: IfNotPresent---apiVersion: kubeadm.k8s.io/v1beta3certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: {}dns: {}etcd:  local:    dataDir: /var/lib/etcdimageRepository: registry.cn-hangzhou.aliyuncs.com/google_containerskind: ClusterConfigurationkubernetesVersion: &lt;kubernetes-version&gt;controlPlaneEndpoint: "&lt;loadbalancer-address&gt;:&lt;port&gt;"networking:  dnsDomain: cluster.local  podSubnet: ""  serviceSubnet: 10.96.0.0/12scheduler: {}EOF</span></code></pre><p>a. 需要修改 <container-sock> docker运行时位置：/var/run/docker.sock  containerd运行时位置：/var/run/containerd/containerd.sock<br>b. 需要修改 <kubernetes-version> 也就是刚才安装的kubeadm 版本。<br>c. 需要修改 <loadbalancer-address>:<port> kubectl链接控制kubernetes集群的地址。（推荐使用域名，解析到所有master节点上）</port></loadbalancer-address></kubernetes-version></container-sock></p><p>执行kuberadm init 初始化集群</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm init --config ./kubeadm-config.yaml --upload-certs <span class="token comment"># upload-certs 自动上传集群证书到各个节点</span><span class="token comment"># 执行完之后会输出</span><span class="token operator">&gt;</span> kubeadm <span class="token function">join</span> <span class="token operator">&lt;</span>loadbalancer-address<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> --token <span class="token operator">&lt;</span>token<span class="token operator">&gt;</span> --discovery-token-ca-cert-hash sha256:<span class="token operator">&lt;</span>hash<span class="token operator">&gt;</span> <span class="token punctuation">\</span><span class="token operator">&gt;</span>--control-plane --certificate-key <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&gt;</span> Please note that the certificate-key gives access to cluster sensitive data, keep it secret<span class="token operator">!</span><span class="token operator">&gt;</span> As a safeguard, uploaded-certs will be deleted <span class="token keyword">in</span> two hours<span class="token punctuation">;</span> If necessary, you can use<span class="token operator">&gt;</span> <span class="token string">"kubeadm init phase upload-certs --upload-certs"</span> to reload certs afterward.<span class="token operator">&gt;</span> Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:<span class="token operator">&gt;</span> kubeadm <span class="token function">join</span> <span class="token operator">&lt;</span>loadbalancer-address<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> --token <span class="token operator">&lt;</span>token<span class="token operator">&gt;</span> --discovery-token-ca-cert-hash sha256:<span class="token operator">&lt;</span>hash<span class="token operator">&gt;</span></code></pre><p>后续work和master节点加入按照输出的token和证书key相应加入。</p><h3 id="5-安装第二个或多个控制节点"><a href="#5-安装第二个或多个控制节点" class="headerlink" title="5. 安装第二个或多个控制节点"></a>5. 安装第二个或多个控制节点</h3><p>依次执行 步骤 1-3 所有命令。<br>执行kubeadm join</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm <span class="token function">join</span> <span class="token operator">&lt;</span>loadbalancer-address<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> --token <span class="token operator">&lt;</span>token<span class="token operator">&gt;</span> --discovery-token-ca-cert-hash sha256:<span class="token operator">&lt;</span>hash<span class="token operator">&gt;</span> --control-plane --certificate-key <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span></code></pre><blockquote><p><strong>WARNING</strong><br>注意 Token 默认只有24小时有效<br>若失效点击此处查看<a href="/2022/06/02/kubeadm-used/">生成token、cert-hash、certificate-key</a></p></blockquote><h3 id="6-安装work节点"><a href="#6-安装work节点" class="headerlink" title="6. 安装work节点"></a>6. 安装work节点</h3><p>依次执行 步骤 1-3 所有命令。<br>执行kubeadm join</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm <span class="token function">join</span> <span class="token operator">&lt;</span>loadbalancer-address<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> --token <span class="token operator">&lt;</span>token<span class="token operator">&gt;</span> --discovery-token-ca-cert-hash sha256:<span class="token operator">&lt;</span>hash<span class="token operator">&gt;</span></code></pre><blockquote><p><strong>WARNING</strong><br>注意 Token 默认只有24小时有效<br>若失效点击此处查看<a href="/2022/06/02/kubeadm-used/">生成token、cert-hash、certificate-key</a></p></blockquote><p>至此一个高可用的kubernetes集群已经安装完成，尽情享受（折腾）吧！</p>]]></content>
      
      
      <categories>
          
          <category> Kubenetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>K8S docker迁移到containerd</title>
      <link href="/2022/06/02/k8s-docker-to-containerd/"/>
      <url>/2022/06/02/k8s-docker-to-containerd/</url>
      
        <content type="html"><![CDATA[<p>由于 kubernetes 从1.24.0版本开始默认禁止使用docker，所以想要升级到1.24.0需要从docker迁移到containerd。</p><p>整个升级步骤总共分为：</p><ol><li>安装并配置containerd；</li><li>排空节点服务，停止并移除docker服务（不是必须），停止kubelet服务；</li><li>配置kubelet使用containerd作为容器运行时；</li><li>重启kubelet服务并验证节点；</li></ol><h4 id="1-安装并配置containerd"><a href="#1-安装并配置containerd" class="headerlink" title="1. 安装并配置containerd"></a>1. 安装并配置containerd</h4><p>由于docker也已切换到containerd上，可以直接参考官方docker安装教程。<br>此处参考docker安装即可，查看 <a href="https://docs.docker.com/engine/install/centos">https://docs.docker.com/engine/install/centos</a></p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/containerdcontainerd config default <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /etc/containerd/config.toml<span class="token comment"># 配置SystemCgroup以及 pause 为中国源</span><span class="token function">vim</span> /etc/containerd/config.toml<span class="token comment"># 查找 [plugins."io.containerd.grpc.v1.cri".cni]</span><span class="token comment"># 更改 SystemdCgroup = false 为 true</span><span class="token comment"># 查找 sandbox_image 并修改 sandbox_image = "registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6" （此处可以修改为私有源）</span>systemctl restart containerdsystemctl <span class="token builtin class-name">enable</span> containerd</code></pre><h4 id="2-排空节点服务停止服务"><a href="#2-排空节点服务停止服务" class="headerlink" title="2. 排空节点服务停止服务"></a>2. 排空节点服务停止服务</h4><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl drain <span class="token operator">&lt;</span>node-name<span class="token operator">&gt;</span> --ignore-daemonsetssystemctl stop kubeletsystemctl stop docker.servicesystemctl disbale docker.service<span class="token punctuation">(</span>不是必须<span class="token punctuation">)</span></code></pre><h4 id="3-配置kubelet使用containerd作为容器运行时"><a href="#3-配置kubelet使用containerd作为容器运行时" class="headerlink" title="3. 配置kubelet使用containerd作为容器运行时"></a>3. 配置kubelet使用containerd作为容器运行时</h4><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl edit no <span class="token operator">&lt;</span>node-name<span class="token operator">&gt;</span><span class="token comment"># 这一命令会打开一个文本编辑器，供你在其中编辑 Node 对象。 要选择不同的文本编辑器，你可以设置 KUBE_EDITOR 环境变量。</span><span class="token comment"># 更改 kubeadm.alpha.kubernetes.io/cri-socket 值，将其从 /var/run/dockershim.sock 改为你所选择的 CRI 套接字路径 （例如：unix:///run/containerd/containerd.sock）。</span><span class="token comment"># 注意新的 CRI 套接字路径必须带有 unix:// 前缀。</span><span class="token comment"># 保存文本编辑器中所作的修改，这会更新 Node 对象。</span><span class="token comment"># 编辑文件 /var/lib/kubelet/kubeadm-flags.env，将 containerd 运行时添加到标志中： --container-runtime=remote 和 --container-runtime-endpoint=unix:///run/containerd/containerd.sock"。</span>systemctl restart kubelet</code></pre><h4 id="4-验证节点"><a href="#4-验证节点" class="headerlink" title="4. 验证节点"></a>4. 验证节点</h4><p>输出如下面所示。CONTAINER-RUNTIME 列给出容器运行时及其版本。</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl get nodes -o wide</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kubenetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>K8S 集群更新</title>
      <link href="/2022/06/02/k8s-upgrade/"/>
      <url>/2022/06/02/k8s-upgrade/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍使用 kubeadm 来对 kubernetes 进行升级更新。<br>大致步骤如下：</p><h3 id="1-查找并下载新版本"><a href="#1-查找并下载新版本" class="headerlink" title="1. 查找并下载新版本"></a>1. 查找并下载新版本</h3><p>控制节点和工作节点都需要执行</p><blockquote><p><strong>NOTE</strong><br>注意：需要更新的版本和当前版本不能跳级，必须迭代升级。例如当前版本 1.17.x，只可以下载更新 1.18.x，不可以直接更新到 1.19.x 以及之后版本。</p></blockquote><h4 id="ubuntu-debian-系"><a href="#ubuntu-debian-系" class="headerlink" title="ubuntu debian 系"></a>ubuntu debian 系</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> update<span class="token function">apt-cache</span> madison kubeadm<span class="token comment"># 在列表中查找最新的 1.24 版本</span><span class="token comment"># 它看起来应该是 1.24.x-00，其中 x 是最新的补丁版本</span><span class="token comment"># 用新的补丁版本替换 1.24.x-00 中的 x</span>apt-mark unhold kubelet kubectl kubeadm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.24</span>.x-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.24</span>.x-00  <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.24</span>.x-00 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>apt-mark hold kubelet kubectl kubeadm</code></pre><h4 id="centos-RHEL-Fedora"><a href="#centos-RHEL-Fedora" class="headerlink" title="centos RHEL Fedora"></a>centos RHEL Fedora</h4><pre class="language-bash" data-language="bash"><code class="language-bash">yum list --showduplicates kubeadm --disableexcludes<span class="token operator">=</span>kubernetes<span class="token comment"># 在列表中查找最新的 1.24 版本</span><span class="token comment"># 它看起来应该是 1.24.x-00，其中 x 是最新的补丁版本</span><span class="token comment"># 用新的补丁版本号替换 1.24.x-00 中的 x</span>yum <span class="token function">install</span> -y kubelet-1.24.x-0 kubectl-1.24.x-0 kubeadm-1.24.x-0 --disableexcludes<span class="token operator">=</span>kubernetes</code></pre><h3 id="2-升级-kubernetes"><a href="#2-升级-kubernetes" class="headerlink" title="2. 升级 kubernetes"></a>2. 升级 kubernetes</h3><p>有需要可以排空节点，此步骤不是必须。</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl drain <span class="token operator">&lt;</span>node-to-drain<span class="token operator">&gt;</span> --ignore-daemonsets</code></pre><blockquote><p><strong>NOTE</strong><br>升级分为控制节点和其他控制节点和工作节点升级，二者升级步骤不同，请注意！</p></blockquote><h4 id="具有-x2F-etc-x2F-kubernetes-x2F-admin-conf-的控制节点执行"><a href="#具有-x2F-etc-x2F-kubernetes-x2F-admin-conf-的控制节点执行" class="headerlink" title="具有 /etc/kubernetes/admin.conf 的控制节点执行"></a>具有 /etc/kubernetes/admin.conf 的控制节点执行</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看升级几乎</span>kubeadm upgrade plan<span class="token comment"># 如有提示需要手动更新的，则需要进行手动更新。</span>kubeadm upgrade apply v1.24.x<span class="token comment"># 执行后看到如下输出则视为升级成功</span><span class="token punctuation">[</span>upgrade/successful<span class="token punctuation">]</span> SUCCESS<span class="token operator">!</span> Your cluster was upgraded to <span class="token string">"v1.24.x"</span><span class="token builtin class-name">.</span> Enjoy<span class="token operator">!</span><span class="token comment"># 执行重启kubelet</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart kubelet</code></pre><h3 id="其他控制节点以及工作节点执行"><a href="#其他控制节点以及工作节点执行" class="headerlink" title="其他控制节点以及工作节点执行"></a>其他控制节点以及工作节点执行</h3><p>其他节点直接执行 kubeadm upgrade node 即可，无需查看升级计划以及Apply</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm upgrade <span class="token function">node</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart kubelet</code></pre><p>升级完成，可以运行 kubectl get node 查看容器版本。</p>]]></content>
      
      
      <categories>
          
          <category> Kubenetes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello Guys</title>
      <link href="/2022/06/02/hello/"/>
      <url>/2022/06/02/hello/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://wanbin.tech/">My-Blog</a>!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>K8S 手动续期证书</title>
      <link href="/2022/06/02/k8s-cert-renew/"/>
      <url>/2022/06/02/k8s-cert-renew/</url>
      
        <content type="html"><![CDATA[<p>使用 kubeadm 安装 kubernetes 集群非常方便，但是也有一个比较烦人的问题就是默认的证书有效期只有一年时间，所以需要考虑证书升级的问题，本文的演示集群版本为 v1.18.18 版本，不保证下面的操作对其他版本也适用，在操作之前一定要先对证书目录进行备份，防止操作错误进行回滚。本文主要介绍两种方式来更新集群证书。</p><h2 id="手动更新证书"><a href="#手动更新证书" class="headerlink" title="手动更新证书"></a>手动更新证书</h2><p>由 kubeadm 生成的客户端证书默认只有一年有效期，我们可以通过 <code>check-expiration</code> 命令来检查证书是否过期：  </p><pre class="language-bash" data-language="bash"><code class="language-bash">$ kubeadm alpha certs check-expiration<span class="token punctuation">[</span>check-expiration<span class="token punctuation">]</span> Reading configuration from the cluster<span class="token punctuation">..</span>.<span class="token punctuation">[</span>check-expiration<span class="token punctuation">]</span> FYI: You can <span class="token function">look</span> at this config <span class="token function">file</span> with <span class="token string">'kubectl -n kube-system get cm kubeadm-config -oyaml'</span>CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGEDadmin.conf                 Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:51 UTC   364d                                    noapiserver                  Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:53 UTC   364d            ca                      noapiserver-etcd-client      Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:53 UTC   364d            etcd-ca                 noapiserver-kubelet-client   Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:53 UTC   364d            ca                      nocontroller-manager.conf    Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:51 UTC   364d                                    noetcd-healthcheck-client    Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:45 UTC   364d            etcd-ca                 noetcd-peer                  Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:45 UTC   364d            etcd-ca                 noetcd-server                Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:45 UTC   364d            etcd-ca                 nofront-proxy-client         Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:53 UTC   364d            front-proxy-ca          noscheduler.conf             Apr <span class="token number">24</span>, <span class="token number">2023</span> 02:51 UTC   364d                                    noCERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGEDca                      Apr <span class="token number">20</span>, <span class="token number">2031</span> <span class="token number">10</span>:49 UTC   8y              noetcd-ca                 Apr <span class="token number">20</span>, <span class="token number">2031</span> <span class="token number">10</span>:49 UTC   8y              nofront-proxy-ca          Apr <span class="token number">20</span>, <span class="token number">2031</span> <span class="token number">10</span>:49 UTC   8y              no</code></pre><p>该命令显示 /etc/kubernetes/pki 文件夹中的客户端证书以及 kubeadm 使用的 KUBECONFIG 文件中嵌入的客户端证书的到期时间/剩余时间。</p><blockquote><p><strong>NOTE</strong><br>kubeadm 不能管理由外部 CA 签名的证书，如果是外部得证书，需要自己手动去管理证书的更新。</p></blockquote><p>另外需要说明的是上面的列表中没有包含 kubelet.conf，因为 kubeadm 将 kubelet 配置为自动更新证书。</p><p>另外 kubeadm 会在控制面板升级的时候自动更新所有证书，所以使用 kubeadm 搭建得集群最佳的做法是经常升级集群，这样可以确保你的集群保持最新状态并保持合理的安全性。但是对于实际的生产环境我们可能并不会去频繁得升级集群，所以这个时候我们就需要去手动更新证书。</p><p>要手动更新证书也非常方便，我们只需要通过 kubeadm alpha certs renew 命令即可更新你的证书，这个命令用 CA（或者 front-proxy-CA ）证书和存储在 /etc/kubernetes/pki 中的密钥执行更新。</p><blockquote><p><strong>NOTE</strong><br>如果是高可用集群，需要在所有Master节点上都要执行。</p></blockquote><h3 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 默认地址为 /etc/kubernetes，使用时请注意替换为自己的kubenetes地址。</span><span class="token comment"># 备份证书</span>$ <span class="token function">mkdir</span> /etc/kubernetes.bak $ <span class="token function">cp</span> -r /etc/kubernetes/pki/ /etc/kubernetes.bak$ <span class="token function">cp</span> /etc/kubernetes/*.conf /etc/kubernetes.bak<span class="token comment"># 备份 etcd 数据目录</span>$ <span class="token function">cp</span> -r /var/lib/etcd /var/lib/etcd.bak<span class="token comment"># 执行更新证书的命令</span>$ kubeadm alpha certs renew all --config<span class="token operator">=</span><span class="token punctuation">{</span>kubeadm.yaml<span class="token punctuation">}</span> <span class="token comment"># kubeadm.yaml 记得替换</span><span class="token comment"># 更新下 kubeconfig 文件</span>$ kubeadm init phase kubeconfig all --config <span class="token punctuation">{</span>kubeadm.yaml<span class="token punctuation">}</span> <span class="token comment"># kubeadm.yaml 记得替换</span><span class="token comment"># 替换 admin 配置文件</span>$ <span class="token function">mv</span> <span class="token environment constant">$HOME</span>/.kube/config <span class="token environment constant">$HOME</span>/.kube/config.old$ <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config$ <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/config<span class="token comment"># 重启 kube-apiserver、kube-controller、kube-scheduler、etcd 这4个容器. </span>$ <span class="token function">docker</span> restart <span class="token punctuation">{</span>apiserver_container<span class="token punctuation">}</span>$ <span class="token function">docker</span> restart <span class="token punctuation">{</span>controller_container<span class="token punctuation">}</span>$ <span class="token function">docker</span> restart <span class="token punctuation">{</span>scheduler_container<span class="token punctuation">}</span>$ <span class="token function">docker</span> restart <span class="token punctuation">{</span>etcd_container<span class="token punctuation">}</span></code></pre><blockquote><p><strong>NOTE</strong><br>以上命令需要在所有 Master 节点上运行。</p></blockquote><p>以上命令即可完成手动更新，使用一下命令来验证证书更新。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token operator">|</span> openssl s_client -showcerts -connect <span class="token number">127.0</span>.0.1:6443 -servername api <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>/dev/null <span class="token operator">|</span> openssl x509 -noout -enddate<span class="token assign-left variable">notAfter</span><span class="token operator">=</span>Apr <span class="token number">24</span> 02:53:20 <span class="token number">2023</span> GMT</code></pre><p>可以看到现在的有效期是一年过后的，证明已经更新成功了。</p>]]></content>
      
      
      <categories>
          
          <category> Kubenetes </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
